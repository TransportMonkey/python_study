## 一、类

类的概念是对事物的抽象(如人类),对象的概念是类的一个实例(某个人)

实例化类与不实例化类：实例化类才能被分配内存。

- 简单定义类

```python
class people:
    def __init__(self, name, age, sex): # 类的初始化化(构造函数)
        # __init__ 不是创建对象的方法，它只是初始化对象
        print(f'调用__init__') # 在类的实例化时，就调用__init__
        self.name = name
        self.age = age
        self.sex = sex
    def personal_data(self):
        people_info = f'-------\n姓名：{self.name}\n年龄：{self.age}\n性别：{self.sex}\n-------'
        print(people_info) # 打印个人信息

ple = people('小明',24,'男') # 使用people类创建对象，传入三个参数
ple.personal_data() # 调用personal_data函数
```

### 面向对象三大特性

- 封装：把共性(属性，函数)搞在一起变成个类。
- 继承：子类继承父类的功能。
- 多态：同一个名字的函数，拥有不同的效果。

当父类初始化函数带有参数，那么在子类的初始化函数中也调用父类的初始化函数(super().__init___())

- 继承关系

```python
class Animal:
    def __init__(self, name):
        print('___调用父类init___')
        self.name = name # 父类给子类继承
        self.__name = name  # 父类不给子类继承
    def eat(self):  # __eat表示不给子类继承这个方法
        print(f'{self.name}在吃东西')

class Dog(Animal): # dog是子类,animal是父类
    def __init__(self):
        super().__init__('旺财') #
dg = Dog()
dg.eat()
```

- 解决多重继承的钻石问题

```python
class A:
    def method(self):
        print("A.method")

class B(A):
    def method(self):
        print("B.method")
        super().method()

class C(A):
    def method(self):
        print("C.method")
        super().method()

class D(B, C):
    def method(self):
        print("D.method")
        super().method()

d = D()
d.method()
# 输出顺序遵循 MRO（D → B → C → A）：
# D.method
# B.method
# C.method
# A.method
```

- 多态关系：同一种操作，作用于不同的对象上，会产生不同的行为。

```python
class Animal:
    def __init__(self, name):
        print('___调用父类init___')
        self.name = name # 父类给子类继承
        self.__name = name  # 父类不给子类继承

    def eat(self):  # __eat表示不给子类继承这个方法
        print(f'{self.name}在吃东西')

    def sound(self):
        pass

class Cat(Animal): # dog是子类,animal是父类
    def __init__(self):
        super().__init__('旺财') #

    def sound(self):
        print('喵喵喵')

class Tiger(Animal): # dog是子类,animal是父类
    def __init__(self):
        super().__init__('旺财') #

    def sound(self):
        print('嗷呜')
def makesound(animal): # 封装
    animal.sound()
cat = Cat()
tiger = Tiger()
makesound(cat)
makesound(tiger)
```

### 属性与对象属性

私有属性：self.__var（实际被重命名为_ClassName__var）

受保护属性：self._var（仅约定，仍可访问）

- 类属性：属于类，并且在该类中所有的对象都共有这个属性。

```python
class A:
    name = '小米'
    
A.name # 使用类属性
```

- 对象属性：属于对象，例：self.xxxx

```python
class People:
    def __init__(self, name, age, sex): # 类的初始化化(构造函数)
        print(f'调用__init__') # 在类的实例化时，就调用__init__
        self.__name = name
        self.__age = age
        self.__sex = sex
       
ple = people('小明',24,'男')
print(ple.__name)
```



### 装饰器

- @classmethod：用于定义**类方法**。类方法与实例方法不同，它不依赖于类的实例，而是与类本身绑定。

```python
class MyClass:
    class_variable = "I am a class variable"

    @classmethod
    def class_method(cls, arg1, arg2):
        print(f"Called with cls={cls}")
        print(f"Args: {arg1}, {arg2}")
        print(f"Access class variable: {cls.class_variable}")
```
- @property:就是“**用属性语法，做方法的事**”;，用 `@property` 暴露只读或受控读写版本，防止脏数据。

```python
class Circle:
    def __init__(self, radius):
        self.radius = radius  # 会调用 setter

    @property
    def radius(self):
        return self._radius

    @radius.setter
    def radius(self, value):
        if value < 0:
            raise ValueError("半径不能为负")
        self._radius = value

# 使用
c = Circle(5)
c.radius = -1  # ❌ ValueError: 半径不能为负
```

- @abstractmethod：**强制要求子类必须实现该方法**，否则子类也会被视为抽象类，无法实例化。

```python
from abc import ABC, abstractmethod

class Animal(ABC):  # 继承 ABC 表示这是一个抽象基类
    @abstractmethod
    def speak(self):
        """子类必须实现这个方法"""
        pass

class Dog(Animal):
    def speak(self):
        return "Woof!"

# 使用
dog = Dog()
print(dog.speak())  # 输出: Woof!

# 如果 Dog 没有实现 speak()，会报错：
# TypeError: Can't instantiate abstract class Dog with abstract method speak
```

- @staticmethod：既不需要访问实例属性，也不需要访问类属性。

```python
class MathUtils:
    @staticmethod
    def add(x, y):
        return x + y

    @staticmethod
    def is_even(n):
        return n % 2 == 0

# 使用
print(MathUtils.add(10, 20))     # 30
print(MathUtils.is_even(7))      # False
```

- 与 `@classmethod` 的区别

| 特性         | `@staticmethod`    | `@classmethod`        |
| ------------ | ------------------ | --------------------- |
| 接收参数     | 无默认参数         | 第一个参数是 `cls`    |
| 访问类属性   | ❌ 不能直接访问     | ✅ 可以通过 `cls` 访问 |
| 访问实例属性 | ❌ 不能访问         | ❌ 不能访问            |
| 使用场景     | 工具方法、逻辑封装 | 工厂方法、修改类状态  |

- @abstractmethod:强制子类必须实现这个方法，否则子类不能实例化。

```python
from abc import ABC, abstractmethod

class Animal(ABC):  # 抽象类
    @abstractmethod
    def speak(self):
        """子类必须实现这个方法"""
        pass

class Dog(Animal):
    def speak(self):
        return "汪汪！"

class Cat(Animal):
    def speak(self):
        return "喵喵~"

# 测试
dog = Dog()  # ✅ 成功，因为 Dog 实现了 speak
cat = Cat()  # ✅ 成功，因为 Cat 实现了 speak

# 如果有一个子类没实现 speak：
class Bird(Animal):
    pass

bird = Bird()  # ❌ 报错：TypeError: Can't instantiate abstract class Bird with abstract method speak
```



### 如何判断回文

```python
def is_palindrome(s):
    s = str(s)  # 确保是字符串
    return s == s[::-1]  # 反转后与原字符串比较

# 示例
print(is_palindrome("racecar"))  # True
print(is_palindrome("hello"))    # False
print(is_palindrome(12321))      # True
```

## 二、实现单例模式

在一个类无论初始化多少次该类，返回的对象都是相同的

```python

class Singleton:
    _instance = None # 类的属性
    def __new__(cls, *args, **kwargs): #
        print(Singleton._instance)
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

s1 = all([Singleton() for i in range(100)])
print(s1)  # True
```